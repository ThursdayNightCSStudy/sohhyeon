# 컴퓨터가 이해하는 정보의 단위

컴퓨터가 이해하는 가장 작은 정보 단위는 비트이다. 전구에 빗대어 생각해보면 전구 한개로 꺼짐 혹은 켜짐을 표현할 수 있다. 이처럼 1비트는 0 또는 1, 두 가지 정보를 표현할 수 있다.

n개의 전구로 표현할 수 있는 상태는 2^n가지이고, 마찬가지로, n개의 비트로 2^n가지 정보를 표현할 수 있다.

웹 브라우저, 워드 프로세서, 포토샵 등 우리가 실행하는 모든 프로그램은 수십만, 수백만 개 이상의 0과 1로 이루어져있다. 일상적으로 우리가 프로그램의 크기를 말할때는 비트보다 큰 단위를 사용한다..

- 1바이트 byte): 8비트
- 1킬로바이트(kB): 1000바이트(1000byte)
- 1메가바이트(MB): 1000킬로바이트(1000kB)
- 1기가바이트(GB): 1000메가바이트(1000MB)
- 1테라바이트(TB): 1000기가바이트(1000GB)

<br>

# 이진법

이진법은 0과 1로만 숫자를 표현한다. 우리는 일상적으로 십진수를 사용하지만, 0과 1밖에 모르는 컴퓨터에게 어떤 숫자를 알려 주려면 십진수가 아닌 이진수로 알려주어야 한다.

십진수를 이진수로 쉽게 변환하는 방법은 다음과 같다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9932AF485C920E9C22" width="30%" />

35를 2진수로 바꾸면 100011(2)가 된다. 정수는 이처럼 바굴 수 있지만, 소수는 어떻게 이진수로 표현할 수 있을까? 실수를 표현하는 방법으로는 고정소수점(fixed point)과 부동소수점(floating point) 방식이 있다.

<br>

# 고정소수점 (Fixed Point)

<img src="../images/img_c_fixed_point.png">

실수는 보통 정수부와 소수부로 나눌 수 있다. 따라서, 소수부의 자릿수를 미리 정하여 고정된 자릿수의 소수를 표현하는 것이다. 위의 이미지에서는 32비트 실수를 고정 소수점 방식으로 표현한 것이다. 맨 앞 1자리는 부호비트(sign bit)라고 해서 0이면 양수, 1이면 음수이다. 소수부는 앞에서부터 채우며 남는 뒷자리는 0으로 채운다.

7.625를 고정 소수점으로 표시하면 다음과 같이 할 수 있다.

1. 7을 2진수로 바꾼다.
2. 0.625 \* 2 = 1.25 -> 1+0.25
3. 0.25 \* 2 = 0.5 -> 0 + 0.5
4. 0.5 \* 2 = 1 -> 1 + 0

따라서 7.625는 32비트 고정소수점으로는 <u><b>00000111.10100000</b></u>로 표현할 수 있다.

고정소수점으로 표현하는 방식은 소수점에 2를 곱했을 때 정수가 빠르게 될수록 자릿수가 적고, 그렇지 않을수록 자릿수가 늘어나는 것을 알 수 있다. 위의 이미지처럼 32비트로 표현하는 경우, 표현할 수 있는 범위가 매우 적어진다는 단점이 있다.

<br>

# 부동소수점 (Floating Point)

<img src="../images/img_c_floating_point_32.png"/>

실수는 보통 정수부와 소수부로 나누지만, 가수부와 지수부로 나누어 표현할 수도 있다. 부동 소수점은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식이다. IEEE 표준에 따르면 부동소수점 방식으로 실수를 저장하는 데는 32비트, 또는 64비트가 사용되며, 위의 이미지는 32비트를 사용하는 구조이다.

부동소수점으로 표현하기 위해서는 정규화라는 과정을 거치는데, 이는 2진수를 1.xxxxx \* 2^n의 형태로 변환하는 것을 말한다.

정규화 방법은 간단한데, 정수부에 1만 남을 때까지 소수점을 왼쪽(정수부가 0일 경우엔 오른쪽)으로 이동시키고 이동한 칸 수만큼 n자리에 집어 넣으면 된다.

111.101을 정규화하면 1.11101 \* 2^2이 된다. (소수점을 왼쪽으로 2칸 움직였으므로)

맨 앞자리는 마찬가지로 부호비트로 0이면 양수, 1이면 음수를 의미한다. 23자리 가수부는 정규화 결과 소수점 오른쪽에 있는 숫자들을 왼쪽부터 그대로 넣으면 된다. 남는 자리는 0으로 채운다.(소수점 왼쪽은 무조건 1이기 때문에 표현하지 않는데, 이 1을 hidden bit라고 부르기도 한다.)

8자리 지수부는 2^n의 n에 127을 더한 값을 2진수로 바꾸어 저장한다.

### 127를 더하는 이유?

지수가 음수인 경우가 있기 때문이다.맨 앞자리 부호비트는 지수의 부호가 아니라 전체 숫자의 부호를 의미하는 것이다. 따라서 지수의 음수를 표현하기 위해 지수용 부호비트를 하나 더 만들지 않기 위해 8비트를 활용해 127이라는 값을 더해준다. 10진수 기준으로 0~127은 음수, 128~255 구간은 양수로 표현하도록 만든 것이다.

### float, double?

프로그래밍 언어에서 32비트로 표현하는 실수를 float, 64비트로 표현하는 실수를 double이라고 한다. double은 지수부가 11비트, 가수부가 52비트이다. 32비트에서 지수에 127을 더해주었다면, 64비트에서는 지수에 1023을 더해준다.

<br>

# 무엇을 사용해야할까?

부동소수점 방식을 사용하면 고정소수점보다 많은 범위를 표현할 수 있다는 점에서 장점을 갖지만, 부동 소수점 방식에 의한 실수의 표현은 항상 오차가 존재한다는 단점을 갖는다.

정규화 과정을 거치고 지수에 127 또는 1023을 더해주며 오차가 발생하는 것이다. 따라서 컴퓨터에서 실수를 표현하는 방법은 정확한 표현이 아니라 근사치를 표현하는 것임을 명심해야 한다.

다음은 부동소수점 방식으로 실수를 표현할때 오차가 발생하는 예시이다.

```js
let sum = 0;

for (let i = 0; i < 1000; i++) {
  sum += 0.1;
}

// 99.9999999999986;
```

0.1을 1000번 더한 합계는 100이되어야 하지만 실제로는 99.999가 출력된다. 이처럼 컴퓨터에서 실수를 가지고 수행하는 모든 연산에는 언제나 작은 오차가 발생한다.
