# 명령어 집합

CPU는 명령어를 실행한다. 세상에는 수많은 CPU 제조사가 있고, CPU마다 규격과 기능, 만듦새가 다 다르다. CPU마다 명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정 방식등에 차이가 있다. CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합(Instruction Set) 또는 명령어 집합 구조(Instruction Set Architecture)라고 한다. 즉 CPU마다 ISA가 다를 수 있다는 것이다.

즉, CPU마다 이해할 수 있는 명령어 모음이 다르고, 그 결과 컴퓨터 구조 및 설계방식이 달라진다.

ISA가 같은 CPU끼리는 서로의 명령어를 이해할 수 있지만, ISA가 다르면 서로의 명령어를 이해하지 못한다. 이런 점에서 볼 때 ISA는 일종의 CPU 언어이다.

국가마다 언어가 다르면, 문화와 생화방식이 다르듯 CPU의 언어인 ISA가 다르면 비단 명령어의 생김새만 달라지는 게 아니라 제어장치가 명령어를 해석하는 방식, 사용되는 레지스트의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라진다. 그리고 이는 곧 CPU 하드웨어 설계에도 큰 영향을 미친다.

다음은 두 가지 CPU 설계 방식 CISC와 RISC를 살펴보도록 하자.

<br>

# CISC (Complex Instruction Set Computer)

CISC는 해석하면 복잡한 명령어 집합을 활용하는 컴퓨터를 의미한다. 여기서 컴퓨터는 'CPU'라고 생각해도 좋다. CISC란, 이름 그대로 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식이다. x86, x86-64는 대표적인 CISC 기반의 ISA이다.

CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용한다. 메모리에 접근하는 주소 지정방식도 다양해서 아주 특별한 상황에서만 사용되는 독특한 주소 지정 방식들도 있다.

<br>

> <b>특징</b><br>

- 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있고, 메모리 공간을 절약할 수 있다. 이는 메모리를 최대한 아끼며 개발해야했던 시절에 인기가 높았다.<br><br>
- 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정하지 않다. 그리고 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 한다. 이는 명령어 파이프라인을 구현하는데 걸림돌이 된다. 이상적으로는 명령어는 소요시간이 동일해야하지만, CISC가 실행하는 명령어는 명령어 수행시간이 길고 가지각색이기 때문에 파이프라인이 효율적으로 명령어를 처리할 수 없다.<br><br>
- 명령어 파이프라인이 제대로 동작하지 않는다는 것은 현대 CPU에서 치명적인 약점이다. 현대 CPU에서 명령어 파이프라인은 높은 성능을 내기 위해 절대 놓쳐서는 안되는 핵심기술이기 때문이다.<br><br>
- CISC는 다양하고 복잡한 명령어를 활용할 수 있지만 자주 사용되는 것만 반복해서 사용된다. 20% 정도의 명령어가 사용된 전체 명령어의 80%를 차지한다.

# RISC (Reduced Instruction Set Computer)

CISC의 한계를 통해 다음과 같은 두 가지 교훈을 얻을 수 있다.

- 빠른 처리를 위해 명령어 파이프라인을 십분 활용해야 한다. 원활한 파이프라이닝을 위해 명령어 길이와 수행시간이 짧고 규격화되어 있어야 한다.<br><br>
- 어차피 자주 쓰이는 명령어만 줄곧 사용된다. 복잡한 기능을 지원하는 명령어를 추가하기보다 자주 쓰이는 기본 명령어를 작고 빠르게 만드는 것이 중요하다.

위의 두 가지 사항을 반영해 탄생한 것이 RISC이다. 이름처럼 RISC는 CISC에 비해 명령어의 종류가 적다. CISC와는 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다. 즉, RISC는 고정 길이 명령어를 활용한다.

명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라인에 최적화되어 있다. 그리고 RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화르 ㄹ추구한다. 그렇기 때문에 CISC보다 주소 지정 방식의 종류가 적은 경우가 많다. 이런 이유로 RISC를 load-store 구조라고 부르기도 한다.

<br>

> <b>특징</b><br>

- RISC는 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극 활용한다. 그렇기 때문에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다.
- 사용간으한 명령어 개수가 CISC보다 적기 때문에 RISC는 CISC보다 많은 명령으로 프로그램을 작동시킨다. 즉, 같은 소스 코드를 컴파일해도 CISC보다 많은 수의 명령어로 변환된다.

<br>

# x86과 ARM

x86 CPU 설계방식은 1978년에 시작되었다. 방 하나를 가득 채울 정도로 엄청난 크기의 컴퓨터가 사용되던 시절이기도 하다. 기술이 마이크로 컴퓨터로 현대화되면서 고성능 및 소형화 설계 요소를 구성하는 방법을 파악하는 것이 과제가 되었다. 이 시기에 미국 캘리포니아대학교 버클리 캠퍼스에서는 컴퓨터 칩의 리소스 사용량을 평가하는 프로젝트가 진행되었다. 버클리 캠퍼스의 프로그래머들이 알아낸 것은 대부분의 프로그램이 명령 집합의 하위 집합 중 극히 일부만 사용한다는 것이다. 따라서 복잡하고 구현하기 어려운(그리고 거의 사용되지 않는) 명령을 삭제하여 사전 정의된 명령 수를 줄이면 나머지 단순한 명령이 더 빨리 실행되어 전력 사용량도 대폭 감소하고 칩이 차지하는 공간도 줄어들게 된다. 이를 가리켜 RISC 라고 한다.
