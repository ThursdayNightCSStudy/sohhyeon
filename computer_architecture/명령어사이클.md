# 명령어 구조

명령어는 연산코드와 오퍼랜드로 구성되어있다. 연산코드(operation code)란, 명령어가 수행할 연산을 의미하고, 오퍼랜드(operand)란, 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미한다. 연산코드는 연산자, 오퍼랜드는 피연산자라고도 부른다.

## 오퍼랜드

오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미한다. 따라서 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다. 많은 경우, 오퍼랜드 필드에는 데이터를 직접 명시하기보다는 데이터가 저장된 위치가 담긴다. 그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다. 오퍼랜드 필드는 명령어 안에 하나도 없거나 여러개가 있을 수도 있다.

```js

mov eax,0 // 오퍼랜드가 2개인 경우
pop rbp // 오퍼랜드가 1개인 경우
ret // 오퍼랜드가 없는 경우
```

오퍼랜드의 개수에 따라 명령어를 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어라고 한다.

## 연산코드

연산코드는 명령어가 수행할 연산을 의미한다. 연산 코드의 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다. (명령어의 종류와 생김새는 CPU마다 다르기 때문에 연산 코드의 종류와 생김새 또한 CPU마다 다르다. 앞으로 설명할 부분은 대부분의 CPU가 공통으로 이해하는 대표적인 연산 코드의 종류이다.)

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

```js
// 데이터 전송
MOVE 데이터를 옮겨라
STORE 메모리에 저장하라
LOAD(FETCH) 메모리에서 CPU로 데이터를 가져와라
PUSH 스택에 데이터를 저장하라
POP 스택의 최상단 데이터를 가져와라

//산술/논리연산
ADD/SUBTRACT/MULTIPLY/DIVIDE
INCREMENT/DECREMENT
AND/OR/NOT:AND/OR/NOT 연산을 수행하라
COMPARE 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라

//제어흐름 변경
JUMP 특정 주소로 실행 순서를 옮겨라
CONDITIONAL JUMP 조건에 부합할때 특정 주소로 실행 순서를 옮겨라
HALT 프로그램의 실행을 멈춰라
CALL 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
RETURN CALL을 호출할 때 저장했던 주소로 돌아가라

//입출력 제어
READ(INPUT) 특정 입출력 장치로부터 데이터를 읽어라
WRITE(OUTPUT) 특정 입출력 장치로부터 데이터를 써라
START IO 입출력 장치를 시작하라
TEST IO 입출력 장치의 상태를 확인하라
```

<br>

# 레지스터의 종류

상용화된 CPU 속 레지스터들은 CPU 마다 이름, 크기, 종류가 매우 다양하다. 여기서는 많은 CPU가 고통으로 포함하고 있는 일부의 레지스터를 학습해보도록 한다.

### 프로그램 카운터 (Program Counter, PC)

프로그램 카운터는 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어들일 명령어의 주소를 저장한다. 프로그램 카운터를 명령어 포인터(IP: Instruction Pointer)라고 부르는 CPU도 있다.

### 명령어 레지스터 (Instruction Register, IR)

명령어 레지스터는 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 보낸다.

### 메모리 주소 레지스터 (Memory Address Register, MAR)

메모리 주소 레지스터는 메모리의 주소를 저장하는 레지스터이다. CPU가 읽어들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

### 메모리 버퍼 레지스터 (Memory Buffer Register, MBR) 또는 메모리 데이터 레지스터 (Memory Data Register, MDR)

메모리 버퍼 레지스터는 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터이다. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다. CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 버퍼 레지스터를 거친다.

### 범용 레지스터 (General Purpose Register)

범용 레지스터는 이름 그대로 다양하고 일반적인 상황에서 자유롭게 사용하는 레지스터이다. MBR은 데이터 버스로 주고받을 값만 저장하고, MAR은 주소 버스로 내보낼 주소값만 저장하지만, 범용 레지스터는 데이터와 주소를 모두 저장할 수 있다. 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 현재 대다수 CPU는 모두 범용 레지스터를 가지고 있다.

### 플래그 레지스터 (Flag Register)

플래그 레지스터는 ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장한다. 플래그 레지스터는 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터이다.

<br>

# 명령어 사이클

CPU가 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고, CPU는 그 흐름을 반복하며 명령어들을 처리해 나간다. 이렇게 하나의 명령어를 처리하는 정형화된 흐름을 명령어 사이클이라고 한다.

우리가 실행하는 프로그램은 수많은 명령어로 이루어져 있고, CPU는 이 명령어들을 하나씩 실행한다. 이때 프로그램 속 각각의 명령어들은 일정한 주기를 반복하며 실행되는데, 이 주기는 명령어 사이클이라고 한다. 즉, 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행된다.

명령어 사이클은 메모리에 있는 명령어를 CPU로 가져오는 <b>인출 사이클(fetch cycle)</b>과 CPU로 가져온 명령어를 실행하는 <b>실행 사이클(execution cycle)</b>이 있다. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계이다.

프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행된다. 즉, CPU는 프로그램 속 명령어를 가져오고 실행하고, 또 가져오고 실행하고를 반복하는 것이다.

다음은 하나의 명령어 사이클이다.

```js
CPU로 실행할 프로그램이 메모리의 1000번지부터 1500번지까지 저장되어있다고 가정하자. 그리고 1000번지에는 1102(2)이 저장되어 있다.

- 프로그램을 처음부터 실행하기 위해 PC에는 1000이 저장된다. 이는 메모리에서 가져올 명령어가 1000번지에 있다는 걸 의미한다.

- 1000번지에 저장된 명령어를 읽어들이기 위해서는 MAR에 1000이 저장되고, 주소 버스로 1000번지로 이동한다.

- 메모리 읽기 제어신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내진다.

- 1000번지에 저장된 값은 데이터 버스를 통해 MBR 또는 MDR로 전달된다.

- PC는 증가되어 다음 명령어를 읽어들일 준비를 한다.

- MBR 또는 MDR에 저장된 값은 IR로 이동한다.

- 제어장치는 MR의 명령어를 해석하고 제어 신호를 발생시킨다.
```
